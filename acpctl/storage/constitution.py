"""
acpctl Constitution File Operations

Handles creation and management of constitutional governance templates.
Manages the .acp/templates/ directory and constitution.md file.

Constitution Structure:
    .acp/
    └── templates/
        └── constitution.md    # Project governing principles

The constitution defines:
- Core Principles: Project-specific development standards
- Enterprise Requirements: Security, compliance, licensing
- Quality Standards: Code quality, testing, documentation

Architecture:
- Template-based constitution creation
- Constitution loading and validation
- UTF-8 encoding for all files

Reference: plan.md (Constitutional Governance), CLAUDE.md
"""

from pathlib import Path
from typing import Optional

# ============================================================
# CONSTITUTION TEMPLATE
# ============================================================

DEFAULT_CONSTITUTION_TEMPLATE = """# Project Constitution

This document defines the governing principles for this project. All specifications,
plans, and code generated by acpctl must adhere to these principles.

Constitutional validation occurs at every phase boundary (governance gates).

## Core Principles

### I. Specifications as First-Class Artifacts

**Principle**: Specifications describe WHAT and WHY, never HOW.

**Requirements**:
- Specifications must be implementation-agnostic
- No framework, language, or technology mentions in spec.md
- Focus on user scenarios, acceptance criteria, and business requirements
- Implementation details belong in plan.md, not spec.md

**Validation**: Governance agent checks for framework/technology mentions in specifications.

### II. Constitutional Governance

**Principle**: Every artifact must pass constitutional validation before workflow continues.

**Requirements**:
- All phases include governance gates
- Constitutional violations must be reported with actionable fixes
- Developers can [R]egenerate, [E]dit constitution, [A]bort, or [I]gnore --force
- No silent bypassing of governance gates

**Validation**: Governance agent runs after each artifact generation phase.

### III. Checkpoint Everything

**Principle**: Workflow state must be persistable at any point for resume capability.

**Requirements**:
- Checkpoints saved automatically after each phase completion
- All state must be JSON-serializable
- Thread IDs preserved for LangGraph continuation
- CLI metadata includes feature_id, status, phases_completed

**Validation**: Checkpoint files must be loadable and validate against schema.

### IV. Pre-flight Over Interruption

**Principle**: Collect all clarifications upfront before workflow execution starts.

**Requirements**:
- Specification Agent asks ALL questions in pre-flight questionnaire
- Maximum 10 questions to keep focus
- No mid-workflow interruptions for clarifications
- Questions must be specific and actionable

**Validation**: Workflow should execute without human input after pre-flight complete.

### V. Progressive Disclosure

**Principle**: Support three verbosity levels for different user needs.

**Requirements**:
- --quiet: Errors and critical messages only
- default: Progress indicators, summaries, results
- --verbose: Agent reasoning, detailed logs, debug info
- All commands must respect verbosity flags

**Validation**: UI output changes based on verbosity level.

### VI. Library-First Architecture

**Principle**: Core logic must be testable independent of CLI wrapper.

**Requirements**:
- acpctl/core/ and acpctl/agents/ are library modules
- CLI commands in acpctl/cli/commands/ are thin wrappers
- Tests can import and test core logic without CLI
- Clear separation: CLI → Core → Agents → Storage

**Validation**: Core modules must not import from acpctl.cli.

### VII. Test-First Development

**Principle**: Tests must be generated before implementation code.

**Requirements**:
- Implementation Agent creates TEST artifacts first
- Tests must FAIL before implementation exists
- Tests must PASS after implementation completes
- TDD cycle enforced through artifact state transitions

**Validation**: Implementation artifacts cannot be marked COMPLETE until tests pass.

## Enterprise Requirements

### Security & Compliance

**Requirements**:
- No hardcoded secrets in code (API keys, passwords, tokens)
- No credentials in constitution or specifications
- Audit trail via checkpoint history
- All dependencies must have compatible licenses (Apache 2.0, MIT, BSD)

**Validation**: Governance agent checks for common secret patterns (API_KEY, SECRET, PASSWORD).

### Performance Standards

**Requirements**:
- acpctl init: < 10 seconds
- acpctl specify: < 10 minutes (including LLM calls)
- Complete workflow (init → implement): < 30 minutes
- All performance goals must be measurable

**Validation**: Performance requirements documented in Technical Context.

## Quality Standards

### Code Quality

**Requirements**:
- All Python code must be type-hinted (mypy strict mode)
- Pydantic models for state validation
- Docstrings for all public functions/classes
- Error handling with custom exceptions (no bare except blocks)

**Validation**: Linting and type checking in CI/CD pipeline.

### Documentation

**Requirements**:
- README.md in repository root
- Docstrings in Google or NumPy style
- Architecture documentation in design docs
- API contracts for all service interfaces

**Validation**: Documentation presence checked during planning phase.

## Governance Process

### Violation Handling

When constitutional violations are detected:

1. **Report**: Governance agent identifies specific violations with line numbers
2. **Fix Suggestions**: Actionable recommendations provided
3. **Interactive Prompt**: User chooses next action:
   - [R]egenerate: Agent regenerates artifact with fixes
   - [E]dit constitution: User modifies principles
   - [A]bort: Stop workflow, preserve checkpoint
   - [I]gnore --force: Bypass gate (requires explicit flag)

### Amendment Process

Constitutional principles can be updated:

1. Edit `.acp/templates/constitution.md` directly
2. Commit changes to version control
3. New governance gates use updated constitution
4. Existing checkpoints retain original constitution snapshot

### Audit Trail

All governance decisions are logged:

- Checkpoint files include governance_passes boolean
- Validation status stored in workflow state
- Constitutional violations logged with timestamps
- Amendment history tracked in git

## Custom Project Principles

*Add your project-specific principles below:*

### Example: API Design Standards

**Principle**: All REST APIs must follow OpenAPI 3.0 specification.

**Requirements**:
- OpenAPI spec required in contracts/api.yaml
- Versioned endpoints (/v1/, /v2/)
- Standard error response format

**Validation**: Governance agent checks for contracts/api.yaml presence.

---

**Constitution Version**: 1.0.0
**Last Updated**: {timestamp}
**Project**: {project_name}
"""

# ============================================================
# CONSTITUTION OPERATIONS
# ============================================================


def create_constitution_template(
    acp_dir: str = ".acp",
    project_name: Optional[str] = None,
    overwrite: bool = False,
) -> Path:
    """
    Create constitutional template file.

    Args:
        acp_dir: ACP directory path (default: ".acp")
        project_name: Project name to include in template
        overwrite: If True, overwrite existing constitution

    Returns:
        Path to created constitution file

    Raises:
        FileExistsError: If constitution exists and overwrite=False
        IOError: If file creation fails

    Example:
        >>> path = create_constitution_template(project_name="MyProject")
        >>> print(path)
        .acp/templates/constitution.md
    """
    # Create templates directory
    templates_path = Path(acp_dir) / "templates"

    try:
        templates_path.mkdir(parents=True, exist_ok=True)
    except OSError as e:
        raise IOError(f"Failed to create templates directory: {e}")

    # Check if constitution already exists
    constitution_path = templates_path / "constitution.md"

    if constitution_path.exists() and not overwrite:
        raise FileExistsError(
            f"Constitution already exists: {constitution_path}. "
            "Use overwrite=True to replace."
        )

    # Generate constitution content
    from datetime import datetime

    constitution_content = DEFAULT_CONSTITUTION_TEMPLATE.format(
        timestamp=datetime.now().isoformat(),
        project_name=project_name or "Unknown Project",
    )

    # Write constitution file
    try:
        constitution_path.write_text(constitution_content, encoding="utf-8")
        return constitution_path
    except IOError as e:
        raise IOError(f"Failed to write constitution file: {e}")


def load_constitution(acp_dir: str = ".acp") -> str:
    """
    Load constitution content from file.

    Args:
        acp_dir: ACP directory path (default: ".acp")

    Returns:
        Constitution content as string

    Raises:
        FileNotFoundError: If constitution file doesn't exist
        IOError: If file read fails

    Example:
        >>> constitution = load_constitution()
        >>> print(constitution[:50])
        # Project Constitution

        This document defines...
    """
    constitution_path = Path(acp_dir) / "templates" / "constitution.md"

    try:
        return constitution_path.read_text(encoding="utf-8")
    except FileNotFoundError:
        raise FileNotFoundError(
            f"Constitution not found: {constitution_path}. "
            "Run 'acpctl init' to create constitutional template."
        )
    except IOError as e:
        raise IOError(f"Failed to read constitution: {e}")


def constitution_exists(acp_dir: str = ".acp") -> bool:
    """
    Check if constitution file exists.

    Args:
        acp_dir: ACP directory path (default: ".acp")

    Returns:
        True if constitution exists, False otherwise

    Example:
        >>> if not constitution_exists():
        ...     create_constitution_template()
    """
    constitution_path = Path(acp_dir) / "templates" / "constitution.md"
    return constitution_path.exists() and constitution_path.is_file()


def get_constitution_path(acp_dir: str = ".acp") -> Path:
    """
    Get path to constitution file.

    Args:
        acp_dir: ACP directory path (default: ".acp")

    Returns:
        Path to constitution file

    Example:
        >>> path = get_constitution_path()
        >>> print(path)
        .acp/templates/constitution.md
    """
    return Path(acp_dir) / "templates" / "constitution.md"


def update_constitution(
    content: str,
    acp_dir: str = ".acp",
) -> Path:
    """
    Update constitution content.

    Args:
        content: New constitution content
        acp_dir: ACP directory path (default: ".acp")

    Returns:
        Path to updated constitution file

    Raises:
        IOError: If file write fails

    Example:
        >>> constitution = load_constitution()
        >>> modified = constitution + "\\n### New Principle\\n..."
        >>> update_constitution(modified)
    """
    constitution_path = Path(acp_dir) / "templates" / "constitution.md"

    # Ensure templates directory exists
    constitution_path.parent.mkdir(parents=True, exist_ok=True)

    try:
        constitution_path.write_text(content, encoding="utf-8")
        return constitution_path
    except IOError as e:
        raise IOError(f"Failed to update constitution: {e}")


def create_acp_directory_structure(acp_dir: str = ".acp") -> None:
    """
    Create complete .acp directory structure.

    Creates:
    - .acp/templates/ (for constitution.md)
    - .acp/state/ (for checkpoint files)

    Args:
        acp_dir: ACP directory path (default: ".acp")

    Raises:
        IOError: If directory creation fails

    Example:
        >>> create_acp_directory_structure()
        >>> # Now .acp/templates/ and .acp/state/ exist
    """
    acp_path = Path(acp_dir)

    try:
        # Create main .acp directory
        acp_path.mkdir(exist_ok=True)

        # Create templates subdirectory
        templates_path = acp_path / "templates"
        templates_path.mkdir(exist_ok=True)

        # Create state subdirectory
        state_path = acp_path / "state"
        state_path.mkdir(exist_ok=True)

    except OSError as e:
        raise IOError(f"Failed to create .acp directory structure: {e}")


def validate_constitution_structure(constitution: str) -> tuple[bool, Optional[str]]:
    """
    Validate constitution structure and content.

    Checks for required sections:
    - Core Principles
    - Enterprise Requirements
    - Quality Standards

    Args:
        constitution: Constitution content to validate

    Returns:
        Tuple of (is_valid: bool, error_message: Optional[str])

    Example:
        >>> constitution = load_constitution()
        >>> valid, error = validate_constitution_structure(constitution)
        >>> if not valid:
        ...     print(f"Invalid constitution: {error}")
    """
    required_sections = [
        "# Project Constitution",
        "## Core Principles",
        "## Enterprise Requirements",
        "## Quality Standards",
    ]

    for section in required_sections:
        if section not in constitution:
            return False, f"Missing required section: {section}"

    # Check for at least one principle
    if "### " not in constitution:
        return False, "Constitution must define at least one principle"

    return True, None
